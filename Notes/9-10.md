```CPU --(virtual address VA)--> MMU* ---(physical address PA) --> Main memory -
^                                                                          |
|                                                                          |
|---------------------------------------------------------------------------```

- used in servers laptops desktops, phones etc

VM as tool for caching
- virtual memory is an array of N contiguous bytes stored on disk
- the contents of the array on disk are cached in physical memory (DRAM cache)
    - these blockes are called pages
    - page = 2^p bytes

Dynamic partitioning - divides computer resources into easily adjustable subsets
External Fragmenting - there might be enough memory however things are so spread out in memory that enough memory can't be allocated for it

compaction - fixes external fragmenting by moving used memory closer together

two techniques to pages
- paging
    - break the memory into fixed size pages
- stimentation

Paging is what we will be focusing on
- breaks the memory into fixed size pages
- larger the page means larger a specific program will run because more can be cached and principles of locality apply

frames/physical pages - blocks that are actually residing on memory
virtual pages - blocks in virtual memory

virtual pages and physical pages have the same size

multiple pages = book

DRAM cache organization
- DRAM cache organization drive by the enormous miss pen
    - DRAM is about 10x slower than SRAM
    - Disk is about 10,000 slower than DRAM

Consequences for having part of the data on memory and part on disk
- size of data we are trying to copy is larger
    - tyoically 4-8 KB, sometimes 4MB
- fully associative
    - any virtual page can be placed in any physical page
    - requires a large mapping function - different from CPU caches
- highly sophisticated, expensive replacement algorithms
    - too complicated and open ended to be implemented in hardware
- write-back rather than write-through

Page Tables
---

Page table - array of page table entries (PTEs) that maps virtual pages to physical pages
- per process kernel data structure in DRAM

Example:
32 Bit system 
1 GB PHysical memory
Suppose that the page size is 2 KB. What is the number of virtual pages and number of physical pages? 

Since it is 32 bit we know that the size of virtual memory can be 4 GB

Number of V. pages = size of the virtual memory / page size
        = 2^32(because 32bit) / 2KB
        = 2^32/2^11
        = 2^21 = around 2 million

Number of P. Pages = size of physical memory / page size
        = 2^30(because 1GB) / 2KB
        = 2^30 / 2^11 = 2^19 = 512000

the page table will be indexed by the page number and will give us the physical pages and virtual pages

Page hit - reference to VM word that is in physical memory (DRAM cache hit)
- based on the page you got from a virtual adderss, you go into a page table and find that the data is up to date and not null

Page fault - reference to VM word that is not in phtsical memory (DRAM cache miss)

Handling page fault
- page miss causes page fault (an exception)
- Page fault handler selects a victim to be evicted (removed from memory) then our newly brought page will replace it and be moved into memory

Steps 
1 find a empty spot in main memory and put data there
2 if there isnt one find a victim
3 overwrite the victim with the new data
4 we update the page table 

Virtual memory works because of locality
- at any point in time programs tend to access a set of active virtual pages called the working set
    - programs with better temporal locality will have smaller working sets
- if (working set size < main memory size)
    - good performance for one process after compulsory misses
- if (SUM(working set sizes) > main memory size)
    - thrashing - performance meltdown where pages are swapped (copied in and out continuously)
- so you want to have more physical memory than working sets to avoid thrashing

VM as a tool for memory management
---
___
Key idea - each process has its own virtual adderss space
- it can view memory as a simple linear array
- mapping function scatters addresses through physical memory
    - well chosed mappings simplify memory allocation and mangement 

if virtual pages use the same memory then they will map to the same physical page only if it is read only

Memory allocation
- each virtual page can be mapped to any physical page
- a virtual page can be stored in different physical pages at different times

Sharing code and data among processes
- map virtual pages to the same physical page

