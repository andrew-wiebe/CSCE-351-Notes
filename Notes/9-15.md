
Page tables
- a page table is an array of page table entries that maps virtual pages to physical pages
    - per process kernal data structure in DRAM

Page fault - reference to MV word that is not in physical memory (DRAM cache miss)

Hnadling page fault
- page miss causes page fault (an exception)
- page fault handler selects a victim to be evicted 

Locality to erserve again
- virtual memory works because of locality
- at any point in time programs tend to access a set of active virtual pages called the working set
    - programs with better temporal locality will have smaller working sets

Simplifying linking and loading

[kernel virtual memory]
[user stack (created at runtime, grows into the space below)]
[                             ]
[memory mapped regior for shared libraries (GROWS INTO THE SPACE ABOVE)]
[                        ]
[run-time heap (created by malloc, grows bottom up into the space above)]
[read/write segment(.data,.bss)]
[Read-only segment (.init,.text,.ridata)]
[unused]

malloc - declared at runtime and not declared beforehand

Linking
- each program has similar virtual address space
- code, stack, and shared libraries always start at the same address

Loading
- execve() allocates virtual apges for .text and .data sections = creates PTE

VM as a tool for memory protection
- extend PTEs with permission bits
- page fualt handler checks these before remapping
    - if violated, send process SIGSEGV(segmentation fault)

VM address translation

Virtual address space
- V = {0,1,...,N-1}
Physical address space
- P = {0,1,...,M-1}
Address translation
- MAP: V -> P union {∅}
- for virtual address a:
    - MAP(a) = a' if data at virtual address a is at physical address a' in P
    - MAP(a) = ∅ if data at virtual address a is not in physical memory 
        - either invalid or stored on disk

Summary of address translation Symbols

Basic Parameters
- N = 2^n - numer of addresses in virtual address space
- M = 2^m - number of addresses in hpysical address space
- P = 2^p - page size (bytes)

EX:
System has
- 32 bit virtual address space
- 24 bit physical address space
- 13 bit page size

N = 2^32
M = 2^24
P = 2^13

Components of the virtual address (VA)
- TLBI - TLB index
- TLBT - TLB tag
- VPO - virtual page offset
- VPN - virtual page number

Components of the physical address (PA)
- PPO - physical page offset (same as VPO)
- PPN - physical page number
- CO - byte offset within cache line
- CI - cache index
- CT - cache tag

Address translation: Page Hit

1. processor sends virtual address to MMU
2-3. MMU fetches PTE from page table in memory
4. MMU sends physical address to cache/memory

Address translation: Page Fault
1. Processor sends virtual address to MMU
2-3. MMU fetches PTE from page table in memory
4. Valid bit is zero so MMU triggers page fault exception
5. Handler identifies vicrim (and if dirty pages it out to disk)
6. handler pages in new page and updates PTE in memory
7. Handler returns to original process, restarting faulting instruction

Tansitional look alike structure
- instead of accessing memory right away we get the page table entry into cache and try to find it which makes it a hit

An example
A 32 bit CPU issues an instruction adderss 0xFE980040
- the address needs to be translated from virtual address to physical address
    - MMU computes the PTEA (assume 4k Page => PTEA = 0xFE980)
        - this is because since the page is 4k which is 2^12, we can say the first 3 digits on the right of the hex are for the page and use the rest for our PTEA
    - MMU uses the PTEA to find PTE (memory resident so must be in cache or main memory)
        - Assume PTE is 0x789
    - MMU uses PTE to produce PA (PA = 0x789040)
        - get this by usnig the page bits from the virtual memory (which is 040) and the PTE which is 789
    - PA is used to access cache for the instruction
        - cache hit => send to CPU
        - Cache miss => bring instruction from main memory to cache then send to CPU

Trasnlation lookaside buffer (TLB) - When things have the same virtual page while ignoring the page offset we can use this
- Small hardware cache in MMU
